<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="Generator" content="EditPlus®">
  <meta name="Author" content="">
  <meta name="Keywords" content="">
  <meta name="Description" content="">
  <title>Document</title>
 </head>
 <body>
    <script>
	  //生成实例对象的传统方法是通过构造函数
	/*	function Point(x,y){
			this.x = x;
			this.y = y;
		}
		Point.prototype.to = function (){
			return ` (${this.x + this.y})`
		}
			
	
		var p = new Point(1,2);
		console.log(p.to());
		  
	
	  //es6提供了更接近传统语言的写法，引入了class(类)这个概念，
        作为对象的模板，通过class关键字，可以定义类，es6的绝大
		部分功能，es5都可以做到，新的class写法只是让对象原型的
		写法更加清晰，更像面向对象编的语法而已，
              和上面的方法等价
         class Point{
		    constructor(x,y){//构造方法==上面的构造函数
				this.x = x;
				this.y = y;
			}//不需要逗号隔开，否则会报错
			to(){//原型上的方法
				return `(${this.x + this.y})`
			}
		}
		var p = new Point(1,2);
	    console.log(p.to());
	    console.log(typeof(Point));//function 
        上面代码表明，类的数据类型就是函数，类本身就指向构造函数
		使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致


		       //prototype
			      传统
	   tag.prototype.to = function (){
		   console.log('prototype')
	   }
       function tag(){
	   }
	   var t = new tag();
	   console.log(t.to())
	         
			     es6
	   class tag{
			constructor(){
				this.x = 'name';
				this.y = 'age';
			}
			to(){
				console.log(this.x,this.y);
			}
		}
		var t = new tag();
		console.log(t.to())
		console.log(t.constructor === tag.prototype.constructor);//true
		//上面代码中，t是tag类的实例,它的constructor方法就是B类圆型的constructor方法。

		    
			Object.assign方法可以一次向类添加多个方法
		
		class person{
			constructor(){
			}
		}
	    Object.assign(person.prototype,{
		    test(){
				console.log('test')//test
			},
			get(){
				console.log('get');//get
			}
		})
		var p = new person();
		console.log(p.test());
		console.log(p.get());
        person.prototype.constructor === person//true
		prototype对象的constructor属性，直接指向类的本身，这与es5的行为一致


		另外，类的内部所有定义的方法，都是不可枚举的,这一点和es5的行为不一致
		class Point{
			constructor(){
				console.log(this);
			}
			to(){
				console.log('to');
			}
		}
	    Object.getOwnPropertyDescriptor(Point.prototype,'to');//enumerable：false,不可被枚举
		Object.getOwnPropertyNames(Point.prototype)
           
		   es5，可被枚举
		function test(){
			this.name = 'lihiu';
			this.age = 18;
		}
		test.prototype = {
		        fn(){},
			    to(){}
		}
       Object.getOwnPropertyDescriptor(test.prototype,'fn')//enumerable:true,可被枚举
		
	   类的属性名，可以采用表达式
	   let meth = 'lihui';
		class Point{
			constructor(){}
			[meth](){console.log('aa')}
		}
		var p = new Point();
		p.lihui();//aa

       

	   2:严格模式
	     类和模块的内部，默认就是严格模式，所以不需要使用user strict指定运行模式，
		 只要你的代码卸载类或模块之中，就只有严格模式可用

		 考虑到未来所有的代码，其实都是运行在模块之中，所有es6实际上把整个语言升级到了严格模式
	   
	   3：constructor方法
	      constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类
		  必须有constructor，如果没有显式定义，一个空的constructor方法会被默认添加
     
		  class Point(){}和class Point(){constorctor(){}}等价

		  上面代码中，定义了一个空的类Point，javascript引擎会自动为他添加一个空的constructor方法。
          constructor方法默认返回实例对象(即this)，完全可以指定返回另外一个对象
		  class Person{
			constructor(){
				
	        	return Object.create(null);//{}
				}
			}
		   var person = new Person();
	 
	       class Person{
			constructor(){
				
	        	return Object.create(null);//{}
				}
			}
		   var person = new Person();

		   new Person instanceof Person//false
		*/
		 
		
        
		
	    
	</script>
 </body>
</html>
